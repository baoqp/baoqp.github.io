<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Cassandra源码阅读随笔2. INSERT的执行, Memtable和CommitLog | Baoqp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="insert语句的解析在前文创建的users表中插入一条记录 1INSERT INTO users(id, age, user_name) VALUES (1, 8, &amp;#x27;tom&amp;#x27;); cql语句首先解析生成一个UpdateStatement的静态内部类ParsedInsert对象，其中主要保存了字段名和字段值，其中字段值是Constants$Literal对象，也就是字面常量，">
<meta property="og:type" content="article">
<meta property="og:title" content="Cassandra源码阅读随笔2. INSERT的执行, Memtable和CommitLog">
<meta property="og:url" content="http://example.com/2019/09/11/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942-INSERT%E7%9A%84%E6%89%A7%E8%A1%8C-Memtable%E5%92%8CCommitLog/index.html">
<meta property="og:site_name" content="Baoqp&#39;s Blog">
<meta property="og:description" content="insert语句的解析在前文创建的users表中插入一条记录 1INSERT INTO users(id, age, user_name) VALUES (1, 8, &amp;#x27;tom&amp;#x27;); cql语句首先解析生成一个UpdateStatement的静态内部类ParsedInsert对象，其中主要保存了字段名和字段值，其中字段值是Constants$Literal对象，也就是字面常量，">
<meta property="og:locale">
<meta property="article:published_time" content="2019-09-11T06:34:05.000Z">
<meta property="article:modified_time" content="2019-11-03T10:13:05.329Z">
<meta property="article:author" content="Bao Qingping">
<meta property="article:tag" content="Cassandra">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Baoqp&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Baoqp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Cassandra源码阅读随笔2-INSERT的执行-Memtable和CommitLog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/11/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942-INSERT%E7%9A%84%E6%89%A7%E8%A1%8C-Memtable%E5%92%8CCommitLog/" class="article-date">
  <time datetime="2019-09-11T06:34:05.000Z" itemprop="datePublished">2019-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Cassandra源码阅读随笔2. INSERT的执行, Memtable和CommitLog
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="insert语句的解析"><a href="#insert语句的解析" class="headerlink" title="insert语句的解析"></a>insert语句的解析</h2><p>在前文创建的users表中插入一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO users(id, age, user_name) VALUES (1, 8, &#x27;tom&#x27;);</span><br></pre></td></tr></table></figure>
<p>cql语句首先解析生成一个UpdateStatement的静态内部类ParsedInsert对象，其中主要保存了字段名和字段值，其中字段值是Constants$Literal对象，也就是字面常量，实际上就是保存了字符串形式的值以及对应的类型。常量的解析以及支持的类型可以从语法文件中找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constant returns [Constants.Literal constant]</span><br><span class="line">    : t=STRING_LITERAL &#123; $constant = Constants.Literal.string($t.text); &#125;</span><br><span class="line">    | t=INTEGER        &#123; $constant = Constants.Literal.integer($t.text); &#125;</span><br><span class="line">    | t=FLOAT          &#123; $constant = Constants.Literal.floatingPoint($t.text); &#125;</span><br><span class="line">    | t=BOOLEAN        &#123; $constant = Constants.Literal.bool($t.text); &#125;</span><br><span class="line">    | t=UUID           &#123; $constant = Constants.Literal.uuid($t.text); &#125;</span><br><span class="line">    | t=HEXNUMBER      &#123; $constant = Constants.Literal.hex($t.text); &#125;</span><br><span class="line">    | &#123; String sign=&quot;&quot;; &#125; (&#x27;-&#x27; &#123;sign = &quot;-&quot;; &#125; )? t=(K_NAN | K_INFINITY) &#123; $constant = Constants.Literal.floatingPoint(sign + $t.text); &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>在prepare()之后会生成一个UpdateStatement对象，UpdateStatement继承自ModificationStatement，同时用来表示insert update和delete操作，用StatementType区分不同的操作。在prepare()过程中会检测提交的值的类型和columnfamily元数据中的对应的列的类型是否兼容，而关于列的信息会保存在processedKeys和columnOperations中，其中前者保存的partition key和clustering key所在的列，而后面保存的是对于普通列的操作。以上面的insert语句为例，id和age保存在processedKeys，Restriction表示列上面的约束条件，此处都是表示相等的EQ；user_name保存到columnOperations，具体的是Operation的子类Constant$Setter，表示设置一个列的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected final Map&lt;ColumnIdentifier, Restriction&gt; processedKeys = new HashMap&lt;&gt;();</span><br><span class="line">private final List&lt;Operation&gt; columnOperations = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>生成UpdateStatement对象之后，调用execute()执行操作，主要逻辑在executeWithoutCondition()方法中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private ResultMessage executeWithoutCondition(QueryState queryState, QueryOptions options)</span><br><span class="line">        throws RequestExecutionException, RequestValidationException &#123;</span><br><span class="line">    ConsistencyLevel cl = options.getConsistency();</span><br><span class="line">    if (isCounter())</span><br><span class="line">        cl.validateCounterForWrite(cfm);</span><br><span class="line">    else</span><br><span class="line">        cl.validateForWrite(cfm.ksName);</span><br><span class="line"></span><br><span class="line">    // 生成Mutation</span><br><span class="line">    Collection&lt;? extends IMutation&gt; mutations = getMutations(options.getValues(), false, cl, queryState.getTimestamp());</span><br><span class="line">    // 应用Mutation</span><br><span class="line">    if (!mutations.isEmpty())</span><br><span class="line">        StorageProxy.mutateWithTriggers(mutations, cl, false);</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>getMutations()方法如下，其中：</p>
<ol>
<li>buildPartitionKeyNames(): 把partition key所在列的值连接在一起，写入到一个ByteBuffer中。对于复合的partion key，允许在最后一列使用IN操作符，所以返回的是一个List。<br>比如现在某个表的partion key由a,b两列组成，update语句的where条件必须包含所有的primary key，其中最后一列可以用IN操作，那么<code>update some_cf set ... where a = &#39;a1&#39; and b in (&#39;b1, b2&#39;)</code>这种语句是合法的。<br>此时buildPartitionKeyNames返回的值就是 (‘a1’, ‘b1’)和(‘a1’, ‘b2’)。</li>
<li>createClusteringPrefixBuilder: 和buildPartitionKeyNames()类似</li>
<li>创建UpdateParameters对象，该对象中prefetchedLists表示当前要操作的记录。比如对于<code>update some_cf set some_column = some_column + 1 where ... </code>这样的更新操作，就需要先把要操作的记录读取出来。对于插入操作，获取不需要先读取的更新操作，prefetchedLists就为空。</li>
<li>构建RowMutation：在循环中构建行记录的变更。此处一个ColumnFamily实例表示一条记录。addUpdateForKey构建了列的column_name和column_value。其中需要注意的column_name不单单是schema定义中的列名，而是会把clustering key作为前缀和原来的列名组合在一起。比如我们插入记录(1, 8, ‘tom’)时，生成的cf中有2列（不包括partion key），键值对分别是(8: ), (8+user_name: ‘tome’)，其中clustering key所在列直接把值作为列名。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Collection&lt;? extends IMutation&gt; getMutations(List&lt;ByteBuffer&gt; variables, boolean local, ConsistencyLevel cl, long now)</span><br><span class="line">        throws RequestExecutionException, RequestValidationException &#123;</span><br><span class="line">    List&lt;ByteBuffer&gt; keys = buildPartitionKeyNames(variables);</span><br><span class="line">    ColumnNameBuilder clusteringPrefix = createClusteringPrefixBuilder(variables);</span><br><span class="line"></span><br><span class="line">    UpdateParameters params = makeUpdateParameters(keys, clusteringPrefix, variables, local, cl, now);</span><br><span class="line"></span><br><span class="line">    Collection&lt;IMutation&gt; mutations = new ArrayList&lt;&gt;();</span><br><span class="line">    for (ByteBuffer key : keys) &#123;</span><br><span class="line">        ColumnFamily cf = UnsortedColumns.factory.create(cfm);</span><br><span class="line">        addUpdateForKey(cf, key, clusteringPrefix, params);</span><br><span class="line">        RowMutation rm = new RowMutation(cfm.ksName, key, cf);</span><br><span class="line">        mutations.add(isCounter() ? new CounterMutation(rm, cl) : rm);</span><br><span class="line">    &#125;</span><br><span class="line">    return mutations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="insert执行"><a href="#insert执行" class="headerlink" title="insert执行"></a>insert执行</h2><p>生成了mutation之后就是执行了，statement的execute()方法中会调用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void mutateWithTriggers(Collection&lt;? extends IMutation&gt; mutations,</span><br><span class="line">                                      ConsistencyLevel consistencyLevel,</span><br><span class="line">                                      boolean mutateAtomically)</span><br><span class="line">        throws WriteTimeoutException, UnavailableException, OverloadedException, InvalidRequestException &#123;</span><br><span class="line"></span><br><span class="line">    // 触发器应用mutation</span><br><span class="line">    Collection&lt;RowMutation&gt; augmented = TriggerExecutor.instance.execute(mutations);</span><br><span class="line"></span><br><span class="line">    if (augmented != null)</span><br><span class="line">        mutateAtomically(augmented, consistencyLevel);</span><br><span class="line">    else if (mutateAtomically)</span><br><span class="line">        mutateAtomically((Collection&lt;RowMutation&gt;) mutations, consistencyLevel);</span><br><span class="line">    else</span><br><span class="line">        mutate(mutations, consistencyLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于例子中没有定义触发器，那么直接进入 mutate(mutations, consistencyLevel)，其中主要调用了StorageProxy的performWrite()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static AbstractWriteResponseHandler performWrite(IMutation mutation,</span><br><span class="line">                                                        ConsistencyLevel consistency_level,</span><br><span class="line">                                                        String localDataCenter,</span><br><span class="line">                                                        WritePerformer performer,</span><br><span class="line">                                                        Runnable callback,</span><br><span class="line">                                                        WriteType writeType)</span><br><span class="line">        throws UnavailableException, OverloadedException &#123;</span><br><span class="line"></span><br><span class="line">    String keyspaceName = mutation.getKeyspaceName();</span><br><span class="line">    AbstractReplicationStrategy rs = Keyspace.open(keyspaceName).getReplicationStrategy();</span><br><span class="line"></span><br><span class="line">    Token tk = StorageService.getPartitioner().getToken(mutation.key());</span><br><span class="line"></span><br><span class="line">    // 根据复制策略和副本数量查找需要写入的节点</span><br><span class="line">    List&lt;InetAddress&gt; naturalEndpoints = StorageService.instance.getNaturalEndpoints(keyspaceName, tk);</span><br><span class="line">    Collection&lt;InetAddress&gt; pendingEndpoints =</span><br><span class="line">            StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, keyspaceName);</span><br><span class="line"></span><br><span class="line">    // 创建异步回调用的handler        </span><br><span class="line">    AbstractWriteResponseHandler responseHandler =</span><br><span class="line">            rs.getWriteResponseHandler(naturalEndpoints, pendingEndpoints, consistency_level, callback, writeType);</span><br><span class="line"></span><br><span class="line">    // 确定存活的节点数量满足consistencyLevel的要求</span><br><span class="line">    responseHandler.assureSufficientLiveNodes();</span><br><span class="line"></span><br><span class="line">    performer.apply(mutation, Iterables.concat(naturalEndpoints, pendingEndpoints), responseHandler,</span><br><span class="line">            localDataCenter, consistency_level);</span><br><span class="line">    return responseHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h3><p>之后分析</p>
<h3 id="执行写入"><a href="#执行写入" class="headerlink" title="执行写入"></a>执行写入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static void sendToHintedEndpoints(final RowMutation rm,</span><br><span class="line">                                         Iterable&lt;InetAddress&gt; targets,</span><br><span class="line">                                         AbstractWriteResponseHandler responseHandler,</span><br><span class="line">                                         String localDataCenter)</span><br><span class="line">        throws OverloadedException &#123;</span><br><span class="line">    // extra-datacenter replicas, grouped by dc</span><br><span class="line">    Map&lt;String, Collection&lt;InetAddress&gt;&gt; dcGroups = null;</span><br><span class="line">    // only need to create a Message for non-local writes</span><br><span class="line">    MessageOut&lt;RowMutation&gt; message = null;</span><br><span class="line"></span><br><span class="line">    for (InetAddress destination : targets) &#123;</span><br><span class="line">        // avoid OOMing due to excess hints.  we need to do this check even for &quot;live&quot; nodes, since we can</span><br><span class="line">        // still generate hints for those if it&#x27;s overloaded or simply dead but not yet known-to-be-dead.</span><br><span class="line">        // The idea is that if we have over maxHintsInProgress hints in flight, this is probably due to</span><br><span class="line">        // a small number of nodes causing problems, so we should avoid shutting down writes completely to</span><br><span class="line">        // healthy nodes.  Any node with no hintsInProgress is considered healthy.</span><br><span class="line">        // 如果有过多的未处理完hints直接抛异常</span><br><span class="line">        if (StorageMetrics.totalHintsInProgress.count() &gt; maxHintsInProgress</span><br><span class="line">                &amp;&amp; (getHintsInProgressFor(destination).get() &gt; 0 &amp;&amp; shouldHint(destination))) &#123;</span><br><span class="line">            throw new OverloadedException(&quot;Too many in flight hints: &quot; + StorageMetrics.totalHintsInProgress.count());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检测目标节点是否存活    </span><br><span class="line">        if (FailureDetector.instance.isAlive(destination)) &#123;</span><br><span class="line">            if (destination.equals(FBUtilities.getBroadcastAddress()) &amp;&amp; OPTIMIZE_LOCAL_REQUESTS) &#123; // 本地操作</span><br><span class="line">                insertLocal(rm, responseHandler);</span><br><span class="line">            &#125; else &#123; // 发送给其他节点处理</span><br><span class="line">                // belongs on a different server</span><br><span class="line">                if (message == null)</span><br><span class="line">                    message = rm.createMessage();</span><br><span class="line">                String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);</span><br><span class="line">                // direct writes to local DC or old Cassandra versions</span><br><span class="line">                // (1.1 knows how to forward old-style String message IDs; updated to int in 2.0)</span><br><span class="line">                if (localDataCenter.equals(dc) || MessagingService.instance().getVersion(destination) &lt; MessagingService.VERSION_20) &#123;</span><br><span class="line">                    MessagingService.instance().sendRR(message, destination, responseHandler, true);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Collection&lt;InetAddress&gt; messages = (dcGroups != null) ? dcGroups.get(dc) : null;</span><br><span class="line">                    if (messages == null) &#123;</span><br><span class="line">                        messages = new ArrayList&lt;&gt;(3); // most DCs will have &lt;= 3 replicas</span><br><span class="line">                        if (dcGroups == null)</span><br><span class="line">                            dcGroups = new HashMap&lt;&gt;();</span><br><span class="line">                        dcGroups.put(dc, messages);</span><br><span class="line">                    &#125;</span><br><span class="line">                    messages.add(destination);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // hintted off处理</span><br><span class="line">            if (!shouldHint(destination))</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            // Schedule a local hint</span><br><span class="line">            submitHint(rm, destination, responseHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dcGroups != null) &#123;</span><br><span class="line">        // for each datacenter, send the message to one node to relay the write to other replicas</span><br><span class="line">        if (message == null)</span><br><span class="line">            message = rm.createMessage();</span><br><span class="line"></span><br><span class="line">        for (Collection&lt;InetAddress&gt; dcTargets : dcGroups.values())</span><br><span class="line">            sendMessagesToNonlocalDC(message, dcTargets, responseHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="insert的本地执行"><a href="#insert的本地执行" class="headerlink" title="insert的本地执行"></a>insert的本地执行</h4><p>insertLocal()方法几经辗转，最终调用的keyspace中的apply()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void apply(RowMutation mutation, boolean writeCommitLog, boolean updateIndexes) &#123;</span><br><span class="line">        // write the mutation to the commitlog and memtables</span><br><span class="line">        Tracing.trace(&quot;Acquiring switchLock read lock&quot;);</span><br><span class="line">        // siwtchLock是用于在切换memtable进行锁定的，普通读写只需加读锁</span><br><span class="line">        switchLock.readLock().lock(); </span><br><span class="line">        try &#123;</span><br><span class="line">            if (writeCommitLog) &#123;</span><br><span class="line">                Tracing.trace(&quot;Appending to commitlog&quot;);</span><br><span class="line">                // 写入commit log</span><br><span class="line">                CommitLog.instance.add(mutation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DecoratedKey key = StorageService.getPartitioner().decorateKey(mutation.key());</span><br><span class="line">            for (ColumnFamily cf : mutation.getColumnFamilies()) &#123;</span><br><span class="line">                ColumnFamilyStore cfs = columnFamilyStores.get(cf.id());</span><br><span class="line">                if (cfs == null) &#123;</span><br><span class="line">                    logger.error(&quot;Attempting to mutate non-existant column family &quot; + cf.id());</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Tracing.trace(&quot;Adding to &#123;&#125; memtable&quot;, cf.metadata().cfName);</span><br><span class="line">                cfs.apply(key, cf, updateIndexes ? cfs.indexManager.updaterFor(key, cf) : SecondaryIndexManager.nullUpdater);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            switchLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>keyspace中的apply()方法又调用了ColumnFamilyStore的apply()方法把数据写入memtable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void apply(DecoratedKey key, ColumnFamily columnFamily, SecondaryIndexManager.Updater indexer) &#123;</span><br><span class="line">    long start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    Memtable mt = getMemtableThreadSafe();</span><br><span class="line">    // 存入memtable</span><br><span class="line">    final long timeDelta = mt.put(key, columnFamily, indexer);</span><br><span class="line"></span><br><span class="line">    // 如果开启了rowCache则更新rowCache</span><br><span class="line">    maybeUpdateRowCache(key);</span><br><span class="line">    metric.writeLatency.addNano(System.nanoTime() - start);</span><br><span class="line">    if (timeDelta &lt; Long.MAX_VALUE)</span><br><span class="line">        metric.colUpdateTimeDeltaHistogram.update(timeDelta);</span><br><span class="line">    mt.maybeUpdateLiveRatio();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hintted-handoff"><a href="#hintted-handoff" class="headerlink" title="hintted handoff"></a>hintted handoff</h4><p>之后分析</p>
<h2 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h2><p>从上面的写入过程中可以看出写入操作是写入到memetable的就返回了，如果这部分数据没有dump到磁盘，程序就退出了，那么内存中的数据就会丢失。为了在这种情况下，可以恢复数据，在写入memtable之前，需要先写入CommitLog。Cassandra的CommitLog类似于WAL日志，是保证数据持久性的一种手段。目前大部分基于LSM Tree的存储系统，一般都采取WAL+Memtable+SSTable的模式，只是具体的实现方式不同，比如Cassandra的SSTable是保存到本地磁盘的，而HBase得SSTable是保存到HDFS。</p>
<p>CommitLog是一个单例，在系统启动的时候实例化，commitlog被所有columnfamily所共享。CommitLog中重要属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 负责数据的写入和刷盘</span><br><span class="line">private final ICommitLogExecutorService executor;</span><br><span class="line"></span><br><span class="line">// 负责分配日志文件</span><br><span class="line">public final CommitLogAllocator allocator;</span><br><span class="line"></span><br><span class="line">public final CommitLogArchiver archiver = new CommitLogArchiver();</span><br><span class="line"></span><br><span class="line">// 当前正在使用的日志文件</span><br><span class="line">public volatile CommitLogSegment activeSegment;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看下CommitLog的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private CommitLog() &#123;</span><br><span class="line">    // 创建log文件的存储目录，默认是/var/lib/cassandra/commitlog</span><br><span class="line">    DatabaseDescriptor.createAllDirectories();</span><br><span class="line"></span><br><span class="line">    // 实例化CommitLogAllocator，并获得一个日志文件作为activeSegment</span><br><span class="line">    allocator = new CommitLogAllocator();</span><br><span class="line">    activateNextSegment();</span><br><span class="line"></span><br><span class="line">    // 根据配置文件实例化ICommitLogExecutorService的实现类</span><br><span class="line">    executor = DatabaseDescriptor.getCommitLogSync() == Config.CommitLogSync.batch</span><br><span class="line">            ? new BatchCommitLogExecutorService()</span><br><span class="line">            : new PeriodicCommitLogExecutorService(this);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先解释下commitlog的大致原理：commit的日志是写入到固定大小的日志文件（用CommitLogSegment）中，当达到阈值之后会生成一个新的日志文件。日志的写入并不是实时写入或刷盘的，而是由ICommitLogExecutorService控制写入过程，根据配置条件进行刷盘。刷盘的策略有定期和批量，分别对应BatchCommitLogExecutorService和PeriodicCommitLogExecutorService，默认为定期刷盘。</p>
<p>下面来看下CommitLogSegment的重要属性，可以看到是基于MappedByteBuffer来实现写入的。此外还有一个cfLastWrite属性，其中保存了在该commit log中有过写入的columnfamily，同时这些数据还没dump到sstable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CommitLogSegment &#123;</span><br><span class="line">    // id的基础值，LogSegment的Id是在此基础上递增，每个log文件对应一个id</span><br><span class="line">    private final static long idBase = System.currentTimeMillis();</span><br><span class="line">    private final static AtomicInteger nextId = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">    // The commit log entry overhead in bytes (int: length + long: head checksum + long: tail checksum)</span><br><span class="line">    static final int ENTRY_OVERHEAD_SIZE = 4 + 8 + 8;</span><br><span class="line"></span><br><span class="line">    // 保存相对于该LogSemgent是dirty的columnfamily，只有cfLastWrite才能删除或回收</span><br><span class="line">    // cache which cf is dirty in this segment to avoid having to lookup all ReplayPositions to decide if we can delete this segment</span><br><span class="line">    private final Map&lt;UUID, Integer&gt; cfLastWrite = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public final long id;</span><br><span class="line"></span><br><span class="line">    private final File logFile;</span><br><span class="line">    private final RandomAccessFile logFileAccessor;</span><br><span class="line"></span><br><span class="line">    private boolean needsSync = false;</span><br><span class="line"></span><br><span class="line">    private final MappedByteBuffer buffer;</span><br><span class="line">    private final Checksum checksum;</span><br><span class="line">    private final DataOutputStream bufferStream;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再来看CommitLogAllocator，CommitLogAllocator中有一个线程执行执行日志文件的分配，分配好未使用的日志文件存放在availableSegments，而当前正在写入和写完但还不能删除或回收的segment保存在activeSegments中。此外，系统中还配置了commitlog可以占用的最大空间（commitlog_total_space_in_mb），如果超过这个值，会调用flushOldestKeyspaces()方法来强制把activeSegments队首的CommitLogSegment中的cfLastWrite属性所包含的columnfamily的memtable刷到磁盘，依此来重用这个队首的这个logSegment。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class CommitLogAllocator &#123;</span><br><span class="line">   </span><br><span class="line">    // Segments that are ready to be used</span><br><span class="line">    private final BlockingQueue&lt;CommitLogSegment&gt; availableSegments = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // Allocations to be run by the thread</span><br><span class="line">    private final BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 正在写入的和写完但还不能删除或回收的segment</span><br><span class="line">    private final ConcurrentLinkedQueue&lt;CommitLogSegment&gt; activeSegments = new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 保存所有CommitLogSegment的大小</span><br><span class="line">    private final AtomicLong size = new AtomicLong();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final Thread allocationThread;</span><br><span class="line">    private volatile boolean run = true;</span><br><span class="line"></span><br><span class="line">    public CommitLogAllocator() &#123;</span><br><span class="line">        // The run loop for the allocation thread</span><br><span class="line">        Runnable runnable = new WrappedRunnable() &#123;</span><br><span class="line">            public void runMayThrow() throws Exception &#123;</span><br><span class="line">                while (run) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Runnable r = queue.poll(TICK_CYCLE_TIME, TimeUnit.MILLISECONDS);</span><br><span class="line">                        if (r != null) &#123;</span><br><span class="line">                            r.run();</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            if (availableSegments.isEmpty() &amp;&amp; (activeSegments.isEmpty() || createReserveSegments)) &#123;</span><br><span class="line">                                logger.debug(&quot;No segments in reserve; creating a fresh one&quot;);</span><br><span class="line">                                createFreshSegment();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; catch (Throwable t) &#123;</span><br><span class="line">                        if (!CommitLog.handleCommitError(&quot;Failed to allocate new commit log segments&quot;, t))</span><br><span class="line">                            return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        allocationThread = new Thread(runnable, &quot;COMMIT-LOG-ALLOCATOR&quot;);</span><br><span class="line">        allocationThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>现在来看写入过程中调用的CommitLog的add()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void add(RowMutation rm) &#123;</span><br><span class="line">    executor.add(new LogRecordAdder(rm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该add()方法封装了LogRecordAdder对象提交给executore，LogRecordAdder继承了Runnable，run()方法中就是调用CommitLogSegment的write()方法实现对activeSegment的写入。</p>
<p>看下默认使用的PeriodicCommitLogExecutorService的实现，发现该类只有一个BlockingQueue来缓存要执行的操作，一个appendingThread来执行所有的IO操作，另一个线程定期向BlockingQueue中提交刷盘操作。我们发现并没有由执行insert操作的线程来执行commit log的写入，而是都交由一个appendingThread来完成，这样可以避免多同一个文件的多线程写入所需要的加锁等操作带来的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class PeriodicCommitLogExecutorService implements ICommitLogExecutorService &#123;</span><br><span class="line"></span><br><span class="line">    // 保存要执行的Runnable，里面封装了对LogSegment的写入操作</span><br><span class="line">    private final BlockingQueue&lt;Runnable&gt; queue;</span><br><span class="line">    protected volatile long completedTaskCount = 0;</span><br><span class="line"></span><br><span class="line">    // 只能Runnable的线程</span><br><span class="line">    private final Thread appendingThread;</span><br><span class="line"></span><br><span class="line">    private volatile boolean run = true;</span><br><span class="line"></span><br><span class="line">    public PeriodicCommitLogExecutorService(final CommitLog commitLog) &#123;</span><br><span class="line">        queue = new LinkedBlockingQueue&lt;Runnable&gt;(DatabaseDescriptor.getCommitLogPeriodicQueueSize());</span><br><span class="line">        Runnable runnable = new WrappedRunnable() &#123;</span><br><span class="line">            public void runMayThrow() throws Exception &#123;</span><br><span class="line">                while (run) &#123;</span><br><span class="line">                    Runnable r = queue.poll(100, TimeUnit.MILLISECONDS);</span><br><span class="line">                    if (r == null)</span><br><span class="line">                        continue;</span><br><span class="line">                    r.run();</span><br><span class="line">                    completedTaskCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                commitLog.sync();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        appendingThread = new Thread(runnable, &quot;COMMIT-LOG-WRITER&quot;);</span><br><span class="line">        appendingThread.start();</span><br><span class="line"></span><br><span class="line">        final Callable syncer = new Callable() &#123;</span><br><span class="line">            public Object call() throws Exception &#123;</span><br><span class="line">                commitLog.sync();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (run) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        FBUtilities.waitOnFuture(submit(syncer));</span><br><span class="line">                        Uninterruptibles.sleepUninterruptibly(DatabaseDescriptor.getCommitLogSyncPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; catch (Throwable t) &#123;</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;PERIODIC-COMMIT-LOG-SYNCER&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>至此，还有一个问题没有明确，一个commit log何时对于一个column family来说是可以移除的。首先在写入的write()方法中会调用markDirty()方法在cfLastWrite中记录某个columnfamily在日志文件中的写入位置，随着写入的进行，该位置增大。当某个logSegment写满，使用新的logSement，位置被重置了，但是新的logSegment的id更大。因此从columnfamily的角度来看(segmentId, position)作为整体是递增的。那什么时候会清除这些记录呢？在ColumnFamilyStore的switchMemtable()方法中会调用CommitLog的discardCompletedSegments()方法，而该方法中会调用CommitLogSegment的markClean()方法来清除这些记录。</p>
<p>在switchMemtable时，会把当前的memtable dump到磁盘，那么该ColumnFamily的数据都持久化了，此时获取当前写入的日志文件和位置(currentSegmentId, currrentPostion)，然后遍历所有的active segment的cfLastWrite，如果有当前columnfamily的记录，且满足 segmentId &lt; currentSegmentId 或 segmentId == currentSegmentId &amp;&amp; position &lt; currrentPostion就可以清除了。如果一个logSegment的cfLastWrite为空，那么说明可以被回收或删除了。</p>
<h2 id="ColumnFamilyStore和Memtable"><a href="#ColumnFamilyStore和Memtable" class="headerlink" title="ColumnFamilyStore和Memtable"></a>ColumnFamilyStore和Memtable</h2><p>在前文中讲到，在创建columnfamily的过程中会生成一个对应的ColumnFamilyStore实例，在实例化ColumnFamilyStore的时候会创建一个Memtable。ColumnFamilyStore的data属性是一个DataTracker对象，DataTracker中View引用了ColumnFamilyStore中所有的memtable和sstable。</p>
<p>Memtable需要一个按照partition key排序的有序容器来保存记录，Cassandra使用ConcurrentSkipListMap来作为这个容器，对应的属性是rows。Cassandra中row的存储和直觉中的不一样，是一个partition key对应一个row，比如现在表定义的PRIMARY KEY是(k1, k2)，现在插入两条数据(v1, v2_1, …) 和(v1, v2_2)，这是两条数据，但是保存的时候是在一个row里面，每个row由很多个cell组成，cell是键值对，键是 clustering key + column name，而这些cell也是根据key有序排列的。</p>
<p>Memtable的put流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">long put(DecoratedKey key, ColumnFamily columnFamily, SecondaryIndexManager.Updater indexer) &#123;</span><br><span class="line">    return resolve(key, columnFamily, indexer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private long resolve(DecoratedKey key, ColumnFamily cf, SecondaryIndexManager.Updater indexer) &#123;</span><br><span class="line">    AtomicSortedColumns previous = rows.get(key);</span><br><span class="line"></span><br><span class="line">    if (previous == null) &#123;</span><br><span class="line">        AtomicSortedColumns empty = cf.cloneMeShallow(AtomicSortedColumns.factory, false);</span><br><span class="line">        // get之后为null, 还是需要用putIfAbsent，因为先get后put不是原子的。</span><br><span class="line">        // 先放一个空的行进去，在后面再把各个列填进去，以免putIfAbsent不成功，白费功夫</span><br><span class="line">        previous = rows.putIfAbsent(new DecoratedKey(key.token, allocator.clone(key.key)), empty);</span><br><span class="line">        if (previous == null)</span><br><span class="line">            previous = empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Pair&lt;Long, Long&gt; pair = previous.addAllWithSizeDelta(cf, allocator, localCopyFunction, indexer);</span><br><span class="line">    currentSize.addAndGet(pair.left);</span><br><span class="line">    currentOperations.addAndGet(cf.getColumnCount() + (cf.isMarkedForDelete() ? 1 : 0) + cf.deletionInfo().rangeCount());</span><br><span class="line">    return pair.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memtable中保存的记录是用AtomicSortedColumns表示的，而还未添加memtable的记录则是一个UnSortedColumns。AtomicSortedColumns中的列是按照列名排列的，因为sstable中保存的数据也是有序的。排序的好处是可以作索引和二分查找，在列的数目很大的情况下查找某几列时可以大幅提高效率。AtomicSortedColumns是线程安全的，里面保存列的容器时SnapTree，使用copy-on-write来保证线程安全，此外操作是原子性，特别是添加多个列，详见下面的addAllWithSizeDelta的说明，该函数的返回值之一是该列在序列化之后大小的改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public Pair&lt;Long, Long&gt; addAllWithSizeDelta(ColumnFamily cm, Allocator allocator,</span><br><span class="line">                                            Function&lt;Column, Column&gt; transformation, SecondaryIndexManager.Updater indexer) &#123;</span><br><span class="line">    /*</span><br><span class="line">     *  此处的操作需要保持原子性和隔离性。为了达到这个目的，先把原来保存各个列的map拷贝一份，</span><br><span class="line">     *  然后写入新的列。当所有的列写完采用CAS操作进行更新。在列数很多的情况下，</span><br><span class="line">     *  在所有列加入后的CAS阶段如果失败了，那么代价就太大了。为了减少这种情况的出现，</span><br><span class="line">     *  没处理完一列就检查一遍，这样可以尽早发现问题，避免不必要的操作。</span><br><span class="line">     */</span><br><span class="line">    Holder current, modified;</span><br><span class="line">    long sizeDelta;</span><br><span class="line">    long timeDelta;</span><br><span class="line"></span><br><span class="line">    main_loop:</span><br><span class="line">    do &#123;</span><br><span class="line">        sizeDelta = 0;</span><br><span class="line">        timeDelta = Long.MAX_VALUE;</span><br><span class="line">        current = ref.get();</span><br><span class="line">        DeletionInfo newDelInfo = current.deletionInfo;</span><br><span class="line">        if (cm.deletionInfo().mayModify(newDelInfo)) &#123;</span><br><span class="line">            newDelInfo = current.deletionInfo.copy().add(cm.deletionInfo());</span><br><span class="line">            sizeDelta += newDelInfo.dataSize() - current.deletionInfo.dataSize();</span><br><span class="line">        &#125;</span><br><span class="line">        modified = new Holder(current.map.clone(), newDelInfo);</span><br><span class="line"></span><br><span class="line">        for (Column column : cm) &#123;</span><br><span class="line">            final Pair&lt;Integer, Long&gt; pair = modified.addColumn(transformation.apply(column), allocator, indexer);</span><br><span class="line">            sizeDelta += pair.left;</span><br><span class="line"></span><br><span class="line">            //We will store the minimum delta for all columns if enabled</span><br><span class="line">            if (enableColUpdateTimeDelta)</span><br><span class="line">                timeDelta = Math.min(pair.right, timeDelta);</span><br><span class="line"></span><br><span class="line">            // bail early if we know we&#x27;ve been beaten</span><br><span class="line">            if (ref.get() != current)</span><br><span class="line">                continue main_loop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (!ref.compareAndSet(current, modified));</span><br><span class="line"></span><br><span class="line">    indexer.updateRowLevelIndexes();</span><br><span class="line"></span><br><span class="line">    return Pair.create(sizeDelta, timeDelta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/11/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942-INSERT%E7%9A%84%E6%89%A7%E8%A1%8C-Memtable%E5%92%8CCommitLog/" data-id="ckzldzrat000utofw9483ab5d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cassandra/" rel="tag">Cassandra</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/15/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943-SSTable%E7%9A%84%E5%86%99%E5%85%A5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Cassandra源码阅读随笔3. SSTable的写入
        
      </div>
    </a>
  
  
    <a href="/2019/09/04/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941-CQL%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E5%BB%BA%E8%A1%A8%E8%BF%87%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Cassandra源码阅读随笔1. CQL的执行和建表过程</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BookKeeper/" rel="tag">BookKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cassandra/" rel="tag">Cassandra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HBase/" rel="tag">HBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Parser-combinator/" rel="tag">Parser combinator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pulasr/" rel="tag">Pulasr</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BookKeeper/" style="font-size: 10px;">BookKeeper</a> <a href="/tags/Cassandra/" style="font-size: 20px;">Cassandra</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/Parser-combinator/" style="font-size: 10px;">Parser combinator</a> <a href="/tags/Pulasr/" style="font-size: 10px;">Pulasr</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/07/Parser-combinator%E5%88%9D%E6%8E%A21-%E7%AE%80%E6%98%93JSON%E8%A7%A3%E6%9E%90%E5%99%A8/">Parser combinator初探1-简易JSON解析器</a>
          </li>
        
          <li>
            <a href="/2019/12/28/Cassandra%E7%AC%94%E8%AE%B01-Compaction%E7%AD%96%E7%95%A5/">Cassandra笔记1-Compaction策略</a>
          </li>
        
          <li>
            <a href="/2019/11/27/HBase%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942-MemStore/">HBase源码阅读随笔2-MemStore</a>
          </li>
        
          <li>
            <a href="/2019/11/17/%E8%AF%91-Pulsar%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/">[译]-Pulsar简要介绍</a>
          </li>
        
          <li>
            <a href="/2019/11/10/%E8%AF%91-BookKeeper%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/">[译]BookKeeper简要介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Bao Qingping<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>