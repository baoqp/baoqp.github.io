<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="Cassandra源码阅读随笔3. SSTable的写入 [ Baoqp's Blog ] "><meta name="theme-color" content="#9be3de"><title>Cassandra源码阅读随笔3. SSTable的写入 [ Baoqp's Blog ] </title><style>@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Abril Fatface';
  font-style: normal;
  font-weight: 400;
  src: local('Abril Fatface'), local('AbrilFatface-Regular'), url(data:font/woff2;base64,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BL3+M1K+NfPvjlJEHZTOrkYvtdprqx0Hka+W/IhsQoUJE0jsPVOhV2itgp3Wame8dsB73DeCOfp+FMSxp2At3aozP1zVQ/tmEpXdveum7kat3CaLXRcmTZHmOveMiqxSteCZOrGKmscOa9WycTUXtRFabrtts1Nb3e5qHtqWPMWtuEkMSdydcarhKoTcVXtBgujKwULbPFJvqywIzBjboUacECG6ajlIews5dBUMkJ/LYHa12gpRLEsBDAAA6raxOaTnbx4GG5J6hdn4twxT1DRvEQZvD6banOa3BbstVh48efHmw5cffwECBQkWIvK/LTbhIkSKEi1GrDjxEiRKkixFqjTpMmTKki1Hrjz5ChQqUqxEqTLlKlSqUq2e+hpoqJHGmmiqmeZhWGKoYfaZ7qXhxhtjnlWWxsBotw0xxWdfjDPDSEfc98l8q33z1XeLrXPKCeu10NJErZzR2kmnXXDWOee90sYVF12yQVsfTXLdVde088Y7o3TQXkedddLFQnb/qVGrq24cuuvhtZ5666WPfvraaZEB+htokLfe2+1GBDbalARuuueWzbbYboejttrmmBHW2O+AvUmRDMb6EEUsHHQoDskRjxRIiVRILev2qn1oaGpomZOB2z/jmn/eUk6tvaZda/5znbhPCguQ7wsEvd1strBI3OYR8ye01+ZO0jbH36oqKm37w90hl2v/wO5o3vIjtpoZx20H) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
</style><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 5.4.1"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">Baoqp's Blog</a></h1><p></p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">Cassandra源码阅读随笔3. SSTable的写入</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">Cassandra源码阅读随笔3. SSTable的写入</a></h2><span class="post__date">2019-09-15</span><a href="/tags/Cassandra/"><span class="post__tags">#Cassandra</span></a></div></div><div class="article__content"><p>从前文知道，我们知道更新操作都是在memtable中完成，在一定条件下需要memtable刷到磁盘。一是为了防止memtable占用内存过大，二是为了回收commit log文件。那这个刷入磁盘条件如何判断？在cassandra的发展过程中，出现过几种策略：</p>
<ol>
<li>定期刷入磁盘（配置memtable_flush_after参数）</li>
<li>根据更新次数（配置memtable_operations参数）</li>
<li>根据吞吐量（配置memtable_throughput参数）</li>
<li>根据内存占用情况（配置memtable_total_space_in_mb参数，默认值是堆内存的1/4）</li>
</ol>
<p>显然第4种策略是最合理的。 那么如何测量内存占用呢？Cassandra中使用jamm这个包，但实际上并不是每次都去准确测量内存占用（因为会很慢，特别是memtable很大的时候）。Cassandra中有个liveRatio属性，该属性的含义是内存占用大小和序列化大小的比例，我们知道内存的java对象除了实际的数据外，还包括对象头等信息，那么一个对象的内存占用是比序列化大小更大的。liveRatio的范围是[1, 64]，默认值是10。在Memtable中，有个currentSize属性，该属性记录了memtable序列化之后的大小，每次写入操作都会更新该值。有个了currentSize之后，再乘以liveRatio就可以估算出当前的内存占用了。现在的问题又变成了如何计算和更新liveRatio。</p>
<p>Memtable的类属性中有个meterExecutor，这是一个单线程的ExecutorService，负责执行测量memtable内存占用的runnable。 Memetable在完成一次写入后，会调用maybeUpdateLiveRatio()方法来判断是否要进行内存占用的测量，判断的依据是当前对memtable的操作次数是上一次测量时的操作次数的10倍（此处的操作次数不是指一次数据写入，而是指一次写入中的列数，再加上deleteInfo相关的数据数量）。从这个依据来看，随着memtable的写入，内存测量的频率会也越来越低，这是合理的，因为总体上数据越来越多，多次算出的liveRatio会越来越接近，从而可以减少计算次数。当需要测量内存的时候会向meterExecutor提交一个MeteringRunnable，在计算出新的ratio，如何比原来的小，那么会保守地设置为<code> memtable.liveRatio = (memtable.liveRatio + newRatio) / 2.0</code>，这样可以尽量减小把内存占用估低从而带来OOM的风险。</p>
<p>Cassandra在启动的时候会启动一个MeteredFlusher单例，之后每隔1秒meteredFlusher会执行一次，看下其run()方法，从中可见不止在所有memtable所占内存超过大小时会flush，如果某个columnfFamilyStore的memtable超过一定的大小，也会开始启动flush。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>       <span class="hljs-type">long</span> <span class="hljs-variable">allowedSize</span> <span class="hljs-operator">=</span> calculateAllowedSize();<br><br>       <span class="hljs-comment">// find how much memory non-active memtables are using</span><br>       <span class="hljs-comment">// 计算非活跃（等待flush）的memtable占用的大小</span><br>       <span class="hljs-type">long</span> <span class="hljs-variable">flushingSize</span> <span class="hljs-operator">=</span> calculateFlushingSize();<br>       <span class="hljs-keyword">if</span> (flushingSize &gt; <span class="hljs-number">0</span>)<br>           logger.debug(<span class="hljs-string">&quot;Currently flushing &#123;&#125; bytes of &#123;&#125; max&quot;</span>, flushingSize, allowedSize);<br><br>       List&lt;ColumnFamilyStore&gt; affectedCFs = affectedColumnFamilies();<br>       <span class="hljs-type">long</span> <span class="hljs-variable">liveSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>       <span class="hljs-comment">// flush CFs using more than 1 / (maximum number of memtables it could have in the pipeline)</span><br>       <span class="hljs-comment">// of the total size allotted. Then, flush other CFs in order of size if necessary.</span><br>       <span class="hljs-keyword">for</span> (ColumnFamilyStore cfs : affectedCFs) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">maxInFlight</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.ceil((<span class="hljs-type">double</span>) (<span class="hljs-number">1</span> <span class="hljs-comment">// live memtable</span><br>                   + <span class="hljs-number">1</span> <span class="hljs-comment">// potentially a flushed memtable being counted by jamm</span><br>                   + DatabaseDescriptor.getFlushWriters()<br>                   + DatabaseDescriptor.getFlushQueueSize())<br>                   / (<span class="hljs-number">1</span> + cfs.indexManager.getIndexesBackedByCfs().size())); <span class="hljs-comment">// TODO</span><br>           <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> cfs.getTotalMemtableLiveSize();<br>           <span class="hljs-comment">// 大小超过允许值</span><br>           <span class="hljs-keyword">if</span> (allowedSize &gt; flushingSize &amp;&amp; size &gt; (allowedSize - flushingSize) / maxInFlight) &#123;<br>               logger.info(<span class="hljs-string">&quot;Flushing high-traffic column family &#123;&#125; (estimated &#123;&#125; bytes)&quot;</span>, cfs, size);<br>               cfs.forceFlush();<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               liveSize += size;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (liveSize + flushingSize &lt;= allowedSize)<br>           <span class="hljs-keyword">return</span>;<br>       logger.info(<span class="hljs-string">&quot;Estimated &#123;&#125; live and &#123;&#125; flushing bytes used by all memtables&quot;</span>, liveSize, flushingSize);<br><br>       Collections.sort(affectedCFs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ColumnFamilyStore&gt;() &#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ColumnFamilyStore lhs, ColumnFamilyStore rhs)</span> &#123;<br>               <span class="hljs-keyword">return</span> Long.compare(lhs.getTotalMemtableLiveSize(), rhs.getTotalMemtableLiveSize());<br>           &#125;<br>       &#125;);<br><br>       <span class="hljs-comment">// 如果已经超过大小限制，按照memtable占用大小排序，从大到小flush，直到占用内存回到设定阈值以下</span><br>       <span class="hljs-comment">// flush largest first until we get below our threshold.</span><br>       <span class="hljs-comment">// although it looks like liveSize + flushingSize will stay a constant, it will not if flushes finish</span><br>       <span class="hljs-comment">// while we loop, which is especially likely to happen if the flush queue fills up (so further forceFlush calls block)</span><br>       <span class="hljs-keyword">while</span> (!affectedCFs.isEmpty()) &#123;<br>           flushingSize = calculateFlushingSize();<br>           <span class="hljs-keyword">if</span> (liveSize + flushingSize &lt;= allowedSize)<br>               <span class="hljs-keyword">break</span>;<br><br>           <span class="hljs-type">ColumnFamilyStore</span> <span class="hljs-variable">cfs</span> <span class="hljs-operator">=</span> affectedCFs.remove(affectedCFs.size() - <span class="hljs-number">1</span>);<br>           <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> cfs.getTotalMemtableLiveSize();<br>           <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>               logger.info(<span class="hljs-string">&quot;Flushing &#123;&#125; to free up &#123;&#125; bytes&quot;</span>, cfs, size);<br>               liveSize -= size;<br>               cfs.forceFlush();<br>           &#125;<br>       &#125;<br><br>       logger.trace(<span class="hljs-string">&quot;Memtable memory usage is &#123;&#125; bytes with &#123;&#125; live&quot;</span>, liveSize + flushingSize, liveSize);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>columnFamilyStore的forceFlush()方法主要调用了该类中的switchMemtable()方法，该方法中主要是向flushWriter提交一个FlushRunnable以及向postFlushExecutor中提交flush完成需要进行的操作。因为在该方法中要获取全局的switchLock，而flush操作是I/O操作，肯定是要异步执行的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public Future&lt;?&gt; switch<span class="hljs-constructor">Memtable(<span class="hljs-params">final</span> <span class="hljs-params">boolean</span> <span class="hljs-params">writeCommitLog</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">forceSwitch</span>)</span> &#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * If we can get the writelock, that means no new updates can come in and</span><br><span class="hljs-comment">        * all ongoing updates to memtables have completed. We can get the tail</span><br><span class="hljs-comment">        * of the log and use it as the starting position for log replay on recovery.</span><br><span class="hljs-comment">        *</span><br><span class="hljs-comment">        * This is why we Keyspace.switchLock needs to be global instead of per-Keyspace:</span><br><span class="hljs-comment">        * we need to schedule discardCompletedSegments calls in the same order as their</span><br><span class="hljs-comment">        * contexts (commitlog position) were read, even though the flush executor</span><br><span class="hljs-comment">        * is multithreaded.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Keyspace</span>.</span></span>switchLock.write<span class="hljs-constructor">Lock()</span>.lock<span class="hljs-literal">()</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           final Future&lt;ReplayPosition&gt; ctx = writeCommitLog ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CommitLog</span>.</span></span>instance.get<span class="hljs-constructor">Context()</span> :<br>                   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Futures</span>.</span></span>immediate<span class="hljs-constructor">Future(ReplayPosition.NONE)</span>;<br><br>           <span class="hljs-comment">// submit the memtable for any indexed sub-cfses, and our own.</span><br>           final List&lt;ColumnFamilyStore&gt; icc = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>           <span class="hljs-keyword">for</span> (ColumnFamilyStore cfs : concat<span class="hljs-constructor">WithIndexes()</span>) &#123;<br>               <span class="hljs-keyword">if</span> (forceSwitch<span class="hljs-operator"> || </span>!cfs.get<span class="hljs-constructor">MemtableThreadSafe()</span>.is<span class="hljs-constructor">Clean()</span>)<br>                   icc.add(cfs);<br>           &#125;<br><br>           final CountDownLatch latch = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(<span class="hljs-params">icc</span>.<span class="hljs-params">size</span>()</span>);<br>           <span class="hljs-keyword">for</span> (ColumnFamilyStore cfs : icc) &#123;<br>               <span class="hljs-comment">// 生成新的memtable替换需要flush的memtable</span><br>               Memtable memtable = cfs.data.switch<span class="hljs-constructor">Memtable()</span>;<br>               <span class="hljs-keyword">if</span> (memtable.is<span class="hljs-constructor">Clean()</span>) &#123;<br>                   cfs.replace<span class="hljs-constructor">Flushed(<span class="hljs-params">memtable</span>, <span class="hljs-params">null</span>)</span>;<br>                   latch.count<span class="hljs-constructor">Down()</span>;<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   logger.info(<span class="hljs-string">&quot;Enqueuing flush of &#123;&#125;&quot;</span>, memtable);<br>                   <span class="hljs-comment">// 向flushWriter提交一个FlushRunnable</span><br>                   memtable.flush<span class="hljs-constructor">AndSignal(<span class="hljs-params">latch</span>, <span class="hljs-params">ctx</span>)</span>;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (metric.memtableSwitchCount.count<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>Long.MAX_VALUE)<br>               metric.memtableSwitchCount.clear<span class="hljs-literal">()</span>;<br>           metric.memtableSwitchCount.inc<span class="hljs-literal">()</span>;<br><br>           <span class="hljs-comment">// when all the memtables have been written, including for indexes, mark the flush in the commitlog header.</span><br>           <span class="hljs-comment">// a second executor makes sure the onMemtableFlushes get called in the right order,</span><br>           <span class="hljs-comment">// while keeping the wait-for-flush (future.get) out of anything latency-sensitive.</span><br>           return postFlushExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-constructor">WrappedRunnable()</span> &#123;<br>               public void run<span class="hljs-constructor">MayThrow()</span> throws InterruptedException, ExecutionException &#123;<br>                   latch.await<span class="hljs-literal">()</span>; <span class="hljs-comment">// 等待所有的flush完成</span><br><br>                   <span class="hljs-keyword">if</span> (!icc.is<span class="hljs-constructor">Empty()</span>) &#123;<br>                       <span class="hljs-keyword">for</span> (SecondaryIndex index : indexManager.get<span class="hljs-constructor">IndexesNotBackedByCfs()</span>) &#123;<br>                           <span class="hljs-comment">// flush any non-cfs backed indexes</span><br>                           logger.info(<span class="hljs-string">&quot;Flushing SecondaryIndex &#123;&#125;&quot;</span>, index);<br>                           index.force<span class="hljs-constructor">BlockingFlush()</span>;<br>                       &#125;<br>                   &#125;<br><br>                   <span class="hljs-keyword">if</span> (writeCommitLog) &#123;<br>                       <span class="hljs-comment">// if we&#x27;re not writing to the commit log, we are replaying the log, so marking</span><br>                       <span class="hljs-comment">// the log header with &quot;you can discard anything written before the context&quot; is not valid</span><br>                       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CommitLog</span>.</span></span>instance.discard<span class="hljs-constructor">CompletedSegments(<span class="hljs-params">metadata</span>.<span class="hljs-params">cfId</span>, <span class="hljs-params">ctx</span>.<span class="hljs-params">get</span>()</span>);<br>                   &#125;<br>               &#125;<br>           &#125;);<br>       &#125; finally &#123;<br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Keyspace</span>.</span></span>switchLock.write<span class="hljs-constructor">Lock()</span>.unlock<span class="hljs-literal">()</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>接着看下FlushRunnable中的主要逻辑如下，简单来说就是创建一个SSTableWriter实例，然后循环所有的记录，调用append()方法进行写入，写入完成后再打开一个SSTableReader，用于后续对该SSTable的读取操作。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">protected void run<span class="hljs-constructor">MayThrow()</span> throws Exception &#123;<br>    long writeSize = get<span class="hljs-constructor">ExpectedWriteSize()</span>;<br>    <span class="hljs-comment">// 获取有足够空间的目录</span><br>    Directories.DataDirectory dataDirectory = get<span class="hljs-constructor">WriteDirectory(<span class="hljs-params">writeSize</span>)</span>;<br>    <span class="hljs-comment">// 获取dataDirectory下保存sstable的子目录</span><br>    File sstableDirectory = cfs.directories.get<span class="hljs-constructor">LocationForDisk(<span class="hljs-params">dataDirectory</span>)</span>;<br>    <span class="hljs-keyword">assert</span> sstableDirectory != null : <span class="hljs-string">&quot;Flush task is not bound to any disk&quot;</span>;<br>    <span class="hljs-comment">// 生成sstable</span><br>    SSTableReader sstable = write<span class="hljs-constructor">SortedContents(<span class="hljs-params">context</span>, <span class="hljs-params">sstableDirectory</span>)</span>;<br>        cfs.replace<span class="hljs-constructor">Flushed(Memtable.<span class="hljs-params">this</span>, <span class="hljs-params">sstable</span>)</span>;<br>    latch.count<span class="hljs-constructor">Down()</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> SSTableReader write<span class="hljs-constructor">SortedContents(Future&lt;ReplayPosition&gt; <span class="hljs-params">context</span>, File <span class="hljs-params">sstableDirectory</span>)</span><br>        throws ExecutionException, InterruptedException &#123;<br>    logger.info(<span class="hljs-string">&quot;Writing &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memtable</span>.</span></span>this.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>    SSTableReader ssTable;<br>    <span class="hljs-comment">// errors when creating the writer that may leave empty temp files.</span><br>    <span class="hljs-comment">// 生成sstable的临时路径，创建SSTableWriter，sstable的路径名的形式是ks-cf(-tmp)-version-fileIndex-component.db</span><br>    SSTableWriter writer = create<span class="hljs-constructor">FlushWriter(<span class="hljs-params">cfs</span>.<span class="hljs-params">getTempSSTablePath</span>(<span class="hljs-params">sstableDirectory</span>)</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// (we can&#x27;t clear out the map as-we-go to free up memory,</span><br>        <span class="hljs-comment">//  since the memtable is being used for queries in the &quot;pending flush&quot; category)</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;RowPosition, AtomicSortedColumns&gt; entry : rows.entry<span class="hljs-constructor">Set()</span>) &#123;<br>            ColumnFamily cf = entry.get<span class="hljs-constructor">Value()</span>;<br>            <span class="hljs-keyword">if</span> (cf.is<span class="hljs-constructor">MarkedForDelete()</span>) &#123; <span class="hljs-comment">// 已经标记为要删除</span><br>                <span class="hljs-comment">// When every node is up, there&#x27;s no reason to write batchlog data out to sstables</span><br>                <span class="hljs-comment">// (which in turn incurs cost like compaction) since the BL write + delete cancel each other out,</span><br>                <span class="hljs-comment">// and BL data is strictly local, so we don&#x27;t need to preserve tombstones for repair.</span><br>                <span class="hljs-comment">// If we have a data row + row level tombstone, then writing it is effectively an expensive no-op so we skip it.</span><br>                <span class="hljs-comment">// See CASSANDRA-4667.</span><br>                <span class="hljs-keyword">if</span> (cfs.name.equals(SystemKeyspace.BATCHLOG_CF)<span class="hljs-operator"> &amp;&amp; </span>cfs.keyspace.get<span class="hljs-constructor">Name()</span>.equals(Keyspace.SYSTEM_KS)<span class="hljs-operator"></span><br><span class="hljs-operator">                        &amp;&amp; </span>!(cf.get<span class="hljs-constructor">ColumnCount()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>))<br>                    continue;<br>                <span class="hljs-comment">// TODO ???</span><br>                <span class="hljs-comment">// Pedantically, you could purge column level tombstones that are past GcGRace when writing to the SSTable.</span><br>                <span class="hljs-comment">// But it can result in unexpected behaviour where deletes never make it to disk, as they are lost</span><br>                    <span class="hljs-comment">// and so cannot override existing column values. So we only remove deleted columns if there</span><br>                <span class="hljs-comment">// is a CF level tombstone to ensure the delete makes it into an SSTable.</span><br>                    <span class="hljs-comment">// We also shouldn&#x27;t be dropping any columns obsoleted by partition and/or range tombstones in case</span><br>                <span class="hljs-comment">// the table has secondary indexes, or else the stale entries wouldn&#x27;t be cleaned up during compaction,</span><br>                <span class="hljs-comment">// and will only be dropped during 2i query read-repair, if at all.</span><br>                <span class="hljs-keyword">if</span> (!cfs.indexManager.has<span class="hljs-constructor">Indexes()</span>)<br>                    <span class="hljs-comment">// 移除删除的列，或者schema中被drop的列</span><br>                    currentSize.add<span class="hljs-constructor">AndGet(-ColumnFamilyStore.<span class="hljs-params">removeDeletedColumnsOnly</span>(<span class="hljs-params">cf</span>, Integer.MIN_VALUE)</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (cf.get<span class="hljs-constructor">ColumnCount()</span> &gt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>cf.is<span class="hljs-constructor">MarkedForDelete()</span>)<br>                writer.append((DecoratedKey) entry.get<span class="hljs-constructor">Key()</span>, cf);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (writer.get<span class="hljs-constructor">FilePointer()</span> &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//filePoint是当前写入的位置</span><br>            ssTable = writer.close<span class="hljs-constructor">AndOpenReader()</span>; <span class="hljs-comment">// 打开SSTable Reader</span><br>            logger.info(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(<span class="hljs-string">&quot;Completed flushing %s (%d bytes) for commitlog position %s&quot;</span>,<br>                    ssTable.get<span class="hljs-constructor">Filename()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">ssTable</span>.<span class="hljs-params">getFilename</span>()</span>).length<span class="hljs-literal">()</span>, context.get<span class="hljs-literal">()</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            writer.abort<span class="hljs-literal">()</span>;<br>            ssTable = null;<br>            logger.info(<span class="hljs-string">&quot;Completed flushing; nothing needed to be retained.  Commitlog position was &#123;&#125;&quot;</span>, context.get<span class="hljs-literal">()</span>);<br>        &#125;<br>        return ssTable;<br>    &#125; catch (Throwable e) &#123;<br>        writer.abort<span class="hljs-literal">()</span>;<br>        throw <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Throwables</span>.</span></span>propagate(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在的重点来到了SSTableWriter类，先看下类中的重要属性</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">private</span> IndexWriter iwriter; <span class="hljs-comment">// 负责索引文件的写入</span><br>  <span class="hljs-keyword">private</span> SegmentedFile.Builder dbuilder;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SequentialWriter dataFile; <span class="hljs-comment">// 负责sstable数据的写入</span><br>  <span class="hljs-keyword">private</span> DecoratedKey lastWrittenKey; <span class="hljs-comment">// 最后一个写入的key</span><br>  <span class="hljs-keyword">private</span> FileMark dataMark;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SSTableMetadata.Collector sstableMetadataCollector; <span class="hljs-comment">// 记录和统计元数据</span><br></code></pre></td></tr></table></figure>
<p>接着看主要的append()方法以及其中的rawAppend()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">append</span><span class="hljs-params">(DecoratedKey decoratedKey, ColumnFamily cf)</span> &#123;<br>       <span class="hljs-keyword">if</span> (decoratedKey.key.remaining() &gt; FBUtilities.MAX_UNSIGNED_SHORT) &#123;<br>           logger.error(<span class="hljs-string">&quot;Key size &#123;&#125; exceeds maximum of &#123;&#125;, skipping row&quot;</span>,<br>                   decoratedKey.key.remaining(),<br>                   FBUtilities.MAX_UNSIGNED_SHORT);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-comment">// 检查是否满足写入数据是有序的,获取当前写入位置</span><br>       <span class="hljs-type">long</span> <span class="hljs-variable">startPosition</span> <span class="hljs-operator">=</span> beforeAppend(decoratedKey);<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">RowIndexEntry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> rawAppend(cf, startPosition, decoratedKey, dataFile.stream);<br>           afterAppend(decoratedKey, startPosition, entry);<br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FSWriteError</span>(e, dataFile.getPath());<br>       &#125;<br>       <span class="hljs-comment">// 更新元数据中的统计数据</span><br>       sstableMetadataCollector.update(dataFile.getFilePointer() - startPosition, cf.getColumnStats());<br>   &#125;<br><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RowIndexEntry <span class="hljs-title function_">rawAppend</span><span class="hljs-params">(ColumnFamily cf, <span class="hljs-type">long</span> startPosition,</span><br><span class="hljs-params">                                         DecoratedKey key, DataOutput out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-comment">// 要么有列内容，或者是个tombstone</span><br>       <span class="hljs-keyword">assert</span> cf.getColumnCount() &gt; <span class="hljs-number">0</span> || cf.isMarkedForDelete();<br><br>       <span class="hljs-comment">// build()中完成了列的写入，并返回了列索引</span><br>       ColumnIndex.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColumnIndex</span>.Builder(cf, key.key, out);<br>       <span class="hljs-type">ColumnIndex</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> builder.build(cf);<br><br>       out.writeShort(END_OF_ROW);<br>       <span class="hljs-keyword">return</span> RowIndexEntry.create(startPosition, cf.deletionInfo().getTopLevelDeletion(), index);<br>   &#125;<br><br><br><br>   	<span class="hljs-comment">// ColumnIndex的build方法</span><br>  		<span class="hljs-keyword">public</span> ColumnIndex <span class="hljs-title function_">build</span><span class="hljs-params">(ColumnFamily cf)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>           <span class="hljs-comment">// cf has disentangled the columns and range tombstones, we need to re-interleave them in comparator order</span><br>           Iterator&lt;RangeTombstone&gt; rangeIter = cf.deletionInfo().rangeIterator();<br>           <span class="hljs-type">RangeTombstone</span> <span class="hljs-variable">tombstone</span> <span class="hljs-operator">=</span> rangeIter.hasNext() ? rangeIter.next() : <span class="hljs-literal">null</span>;<br>           Comparator&lt;ByteBuffer&gt; comparator = cf.getComparator();<br><br>           <span class="hljs-keyword">for</span> (Column c : cf) &#123;<br>               <span class="hljs-comment">// 按照名称顺序写入，如果RangeTombstone.min在前，则先写RangeTombstone</span><br>               <span class="hljs-keyword">while</span> (tombstone != <span class="hljs-literal">null</span> &amp;&amp; comparator.compare(c.name(), tombstone.min) &gt;= <span class="hljs-number">0</span>) &#123;<br>                   add(tombstone);<br>                   tombstone = rangeIter.hasNext() ? rangeIter.next() : <span class="hljs-literal">null</span>;<br>               &#125;<br>               add(c);<br>           &#125;<br><br>           <span class="hljs-keyword">while</span> (tombstone != <span class="hljs-literal">null</span>) &#123;<br>               add(tombstone);<br>               tombstone = rangeIter.hasNext() ? rangeIter.next() : <span class="hljs-literal">null</span>;<br>           &#125;<br>           <span class="hljs-type">ColumnIndex</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> build();<br><br>           maybeWriteEmptyRowHeader();<br><br>           <span class="hljs-keyword">return</span> index;<br>       &#125;<br><br><br>	<span class="hljs-comment">// ColumnIndex的add方法</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(OnDiskAtom column)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>           atomCount++;<br><br>           <span class="hljs-keyword">if</span> (firstColumn == <span class="hljs-literal">null</span>) &#123;<br>               firstColumn = column;<br>               startPosition = endPosition;<br>               <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> have that use the firstColumn as min + make sure we optimize that on read</span><br>               <span class="hljs-comment">// 计算indexBlock开头需要写入的RangeTombstone，并返回写入的大小</span><br>               endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);<br>               blockSize = <span class="hljs-number">0</span>; <span class="hljs-comment">// We don&#x27;t count repeated tombstone marker in the block size, to avoid a situation</span><br>               <span class="hljs-comment">// where we wouldn&#x27;t make any progress because a block is filled by said marker</span><br>           &#125;<br><br>           <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> column.serializedSizeForSSTable();<br>           endPosition += size;<br>           blockSize += size;<br><br>           <span class="hljs-comment">// if we hit the column index size that we have to index after, go ahead and index it.</span><br>           <span class="hljs-comment">// 当达到column_index_size_in_kb大小生成一个IndexInfo，同时开始一个新的block</span><br>           <span class="hljs-keyword">if</span> (blockSize &gt;= DatabaseDescriptor.getColumnIndexSize()) &#123;<br>               IndexHelper.<span class="hljs-type">IndexInfo</span> <span class="hljs-variable">cIndexInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexHelper</span>.IndexInfo(firstColumn.name(),<br>                       column.name(), indexOffset + startPosition, endPosition - startPosition);<br>               result.columnsIndex.add(cIndexInfo);<br>               firstColumn = <span class="hljs-literal">null</span>;<br>               lastBlockClosing = column;<br>           &#125;<br><br>           <span class="hljs-comment">// 写入rowHeader,包括key和行级别的deleteInfo</span><br>           maybeWriteRowHeader();<br><br>           <span class="hljs-comment">// 写入column</span><br>           atomSerializer.serializeForSSTable(column, output);<br><br>           <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Should deal with removing unneeded tombstones</span><br>           <span class="hljs-comment">// 移除不再会和后面的列有交集的RangeTombStone</span><br>           tombstoneTracker.update(column, <span class="hljs-literal">false</span>);<br><br>           lastColumn = column;<br>       &#125;<br></code></pre></td></tr></table></figure>
<p>在rawAppend()方法中出现了ColumnIndex类，顾名思义，该类表示给列加索引。因为Cassandra中的一行允许有很多列（最多2亿），显然这么多列在没有索引的情况下读取会很慢。在写入一行记录的时候会给column做索引，而Column索引（也称为promoted index）是每隔column_index_size_in_kb大小（称为IndexBolck）创建一个索引（并不是每隔几列，因为磁盘的读取是以Block为单位的），用IndexHelper.IndexInfo表示，如下图所示（图片来自参考文章2）。索引中包括该index block的第一个column和最后一个column。column index使得我们可以跳过前面的block来直接读取某些列所在的block，减少了IO操作的次数。此外我们需要在每个block的开头写入和该block相交的所有rangTombstone（表示列名落在该区间的列都被打上了删除标记），比如某个rangeTombstone的覆盖的区间很大，包含了当前block在内的多个block，那么该rangeTombstone是保存在block之前的，而要读取当前block又需要知道该block的所有相交的rangeTombstone，就需要在写入的时候，把rangeTomestone也写入当前block。rangeTombstone和column都是OnDiskAtom，从这里可以看出OnDiskAtom并不是严格有序的，但是column是严格有序的，但这并不会造成任何问题。<br><img src="column_index.png" alt="column index"></p>
<p>rawAppend()方法最后返回了RowIndexEntry实例，其中记录了该行数据在sstable的起始位置以及column index，之后会调用afterAppend()方法把RowIndexEntry写入索引文件，其中主要调用了IndexWriter的append()方法，其中除了把key和对应的索引项写入索引文件，还每隔indexInterval项，向IndexSummaryBuilder中写入索引项的key和在索引文件中的位置。IndexSummary相当于是索引的索引，即整个索引是两层索引：底层是数据记录的索引，一行记录一个索引，是稠密索引；上层是稀疏索引，每隔indexInterval项，给记录索引创建一个索引。indexInterval默认是128，如果记录数增多，那么indexSummary中的项也会增大，但是indexSummary需要常驻内存，所以不能无限增长，默认最多项目是Integer.MAX_VALUE，超过了限制就会增大interval。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 追加index项到index文件</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">append</span>(DecoratedKey <span class="hljs-built_in">key</span>, RowIndexEntry indexEntry) &#123;<br>   	<span class="hljs-comment">// 向bloom filter写入数据</span><br>       bf.<span class="hljs-property">add</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">key</span>);<br>       <span class="hljs-comment">// 索引文件当前的写入位置</span><br>       <span class="hljs-type">long</span> indexPosition = indexFile.<span class="hljs-property">getFilePointer</span>();<br>       <span class="hljs-keyword">try</span> &#123;<br>       	<span class="hljs-comment">// 写入key</span><br>           ByteBufferUtil.<span class="hljs-property">writeWithShortLength</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">key</span>, indexFile.<span class="hljs-property">stream</span>);<br>           <span class="hljs-comment">// 写入索引项</span><br>           RowIndexEntry.<span class="hljs-property">serializer</span>.<span class="hljs-property">serialize</span>(indexEntry, indexFile.<span class="hljs-property">stream</span>);<br>       &#125; <span class="hljs-title function_">catch</span> (IOException e) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">FSWriteError</span>(e, indexFile.<span class="hljs-property">getPath</span>());<br>       &#125;<br><br>          	<br>       summary.<span class="hljs-property">maybeAddEntry</span>(<span class="hljs-built_in">key</span>, indexPosition);<br>       builder.<span class="hljs-property">addPotentialBoundary</span>(indexPosition);<br>   &#125;<br><br><br>   <span class="hljs-comment">// IndexSummaryBuilder的maybeAddEntry()</span><br>   <span class="hljs-keyword">public</span> IndexSummaryBuilder <span class="hljs-title function_">maybeAddEntry</span>(DecoratedKey decoratedKey, <span class="hljs-type">long</span> indexPosition) &#123;<br>   	<span class="hljs-comment">// 每隔indexInterval写入key和在索引文件中的位置。</span><br>       <span class="hljs-keyword">if</span> (keysWritten % indexInterval == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-type">byte</span>[] <span class="hljs-built_in">key</span> = ByteBufferUtil.<span class="hljs-property">getArray</span>(decoratedKey.<span class="hljs-property">key</span>);<br>           keys.<span class="hljs-property">add</span>(<span class="hljs-built_in">key</span>);<br>           offheapSize += <span class="hljs-built_in">key</span>.<span class="hljs-property">length</span>;<br>           positions.<span class="hljs-property">add</span>(indexPosition);<br>           offheapSize += TypeSizes.<span class="hljs-property">NATIVE</span>.<span class="hljs-property">sizeof</span>(indexPosition);<br>       &#125;<br>       keysWritten++;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>IndexSummary是保存在堆外内存中的，具体的内存布局在IndexSummaryBuilder的build()方法中。 首先整个大小为 所有key的长度总和 + 表示indexFile中位置的long型pisition变量 + key.size() * 4，其中最后为key.size()个整数，表示IndexSummary项在该段内存中的偏移量，如下图所示。根据前后两个偏移量就可以知道一个IndexSummary项的长度，由于Position是long类型，固定为8个字节，因此可以计算出key的长度，所以写入的时候虽然key是变长的，但是并没有key的长度。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">public IndexSummary build(IPartitioner partitioner) &#123;<br>    <span class="hljs-built_in">assert</span> <span class="hljs-built_in">keys</span> != null &amp;&amp; <span class="hljs-built_in">keys</span>.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">assert</span> <span class="hljs-built_in">keys</span>.<span class="hljs-built_in">size</span>() == positions.<span class="hljs-built_in">size</span>();<br><br>    Memory memory = Memory.allocate(offheapSize + (<span class="hljs-built_in">keys</span>.<span class="hljs-built_in">size</span>() * <span class="hljs-number">4</span>));<br>    int idxPosition = <span class="hljs-number">0</span>;<br>    int keyPosition = <span class="hljs-built_in">keys</span>.<span class="hljs-built_in">size</span>() * <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">keys</span>.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-comment">// 写入每一项在memory的偏移量 </span><br>        memory.setInt(idxPosition, keyPosition);<br>        idxPosition += TypeSizes.NATIVE.<span class="hljs-built_in">sizeof</span>(keyPosition);<br><br>        byte[] temp = <span class="hljs-built_in">keys</span>.<span class="hljs-built_in">get</span>(i);<br>        memory.setBytes(keyPosition, temp, <span class="hljs-number">0</span>, temp.length);<br>        keyPosition += temp.length;<br>        long tempPosition = positions.<span class="hljs-built_in">get</span>(i);<br>        memory.setLong(keyPosition, tempPosition);<br>        keyPosition += TypeSizes.NATIVE.<span class="hljs-built_in">sizeof</span>(tempPosition);<br>    &#125;<br>    return new IndexSummary(partitioner, memory, <span class="hljs-built_in">keys</span>.<span class="hljs-built_in">size</span>(), indexInterval);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="index_summary.png" alt="column index"></p>
<p>至此，一条记录的append过程处理完毕。</p>
<p><strong>Reference</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://thelastpickle.com/blog/2011/05/04/How-are-Memtables-measured.html">https://thelastpickle.com/blog/2011/05/04/How-are-Memtables-measured.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zqhxuyuan.github.io/2016/10/19/Cassandra-Code-StorageEngine/">https://zqhxuyuan.github.io/2016/10/19/Cassandra-Code-StorageEngine/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://distributeddatastore.blogspot.com/2013/08/cassandra-sstable-storage-format.html">http://distributeddatastore.blogspot.com/2013/08/cassandra-sstable-storage-format.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/34570367/cassandra-3-0-updated-sstable-format">https://stackoverflow.com/questions/34570367/cassandra-3-0-updated-sstable-format</a></p>
</li>
</ol>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a href="mailto:baoqp1@163.com">Mail</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BookKeeper/" rel="tag">BookKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cassandra/" rel="tag">Cassandra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HBase/" rel="tag">HBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Parser-combinator/" rel="tag">Parser combinator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Presto/" rel="tag">Presto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pulasr/" rel="tag">Pulasr</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2019/09/20/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%944-%E5%93%88%E5%B8%8C%E7%8E%AF%E5%92%8Chinted-handoff/">Cassandra源码阅读随笔4. 哈希环和hinted handoff</a><a class="next-button" href="/2019/09/11/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942-INSERT%E7%9A%84%E6%89%A7%E8%A1%8C-Memtable%E5%92%8CCommitLog/">Cassandra源码阅读随笔2. INSERT的执行, Memtable和CommitLog</a></div></div></div></div><div class="footer"><span>©️2019-2022 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>