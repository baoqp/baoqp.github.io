<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Cassandra源码阅读随笔7. COMPACTION | Baoqp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="回顾前面的SELECT执行过程，我们可以知道随着sstable的数量增加，读取性能会不断下降，因此需要控制sstable的数量。和其他基于LSM的存储系统，Cassandra中也是通过合并（compaction）来合并不同版本的数据、移除tombstone，以此来减少sstable数量。 合并操作是在后台触发的，可以手动触发，也可以自动触发，主要的入口是CompactionManager的subm">
<meta property="og:type" content="article">
<meta property="og:title" content="Cassandra源码阅读随笔7. COMPACTION">
<meta property="og:url" content="http://example.com/2019/10/10/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%947-COMPACTION/index.html">
<meta property="og:site_name" content="Baoqp&#39;s Blog">
<meta property="og:description" content="回顾前面的SELECT执行过程，我们可以知道随着sstable的数量增加，读取性能会不断下降，因此需要控制sstable的数量。和其他基于LSM的存储系统，Cassandra中也是通过合并（compaction）来合并不同版本的数据、移除tombstone，以此来减少sstable数量。 合并操作是在后台触发的，可以手动触发，也可以自动触发，主要的入口是CompactionManager的subm">
<meta property="og:locale">
<meta property="article:published_time" content="2019-10-10T12:17:08.000Z">
<meta property="article:modified_time" content="2019-11-03T10:52:31.269Z">
<meta property="article:author" content="Bao Qingping">
<meta property="article:tag" content="Cassandra">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Baoqp&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Baoqp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Cassandra源码阅读随笔7-COMPACTION" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/10/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%947-COMPACTION/" class="article-date">
  <time datetime="2019-10-10T12:17:08.000Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Cassandra源码阅读随笔7. COMPACTION
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>回顾前面的SELECT执行过程，我们可以知道随着sstable的数量增加，读取性能会不断下降，因此需要控制sstable的数量。和其他基于LSM的存储系统，Cassandra中也是通过合并（compaction）来合并不同版本的数据、移除tombstone，以此来减少sstable数量。</p>
<p>合并操作是在后台触发的，可以手动触发，也可以自动触发，主要的入口是CompactionManager的submitBackground()方法，可以看到合并操作由一个线程池负责执行。该方法的注释中提到每当可能需要执行合并操作就可以调用该方法。通常在启动或把memetable刷入磁盘时会调用该方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Future&lt;?&gt;&gt; submitBackground(final ColumnFamilyStore cfs) &#123;</span><br><span class="line">    if (cfs.isAutoCompactionDisabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Autocompaction is disabled&quot;);</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int count = compactingCF.count(cfs);</span><br><span class="line">    if (count &gt; 0 &amp;&amp; executor.getActiveCount() &gt;= executor.getMaximumPoolSize()) &#123; </span><br><span class="line">        // 运行的任务太多，直接返回</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // we must schedule it at least once, otherwise compaction will stop for a CF until next flush</span><br><span class="line">    do &#123;</span><br><span class="line">        compactingCF.add(cfs);</span><br><span class="line">        futures.add(executor.submit(new BackgroundCompactionTask(cfs)));</span><br><span class="line">        // if we have room for more compactions, then fill up executor</span><br><span class="line">    &#125; while (executor.getActiveCount() + futures.size() &lt; executor.getMaximumPoolSize());</span><br><span class="line"></span><br><span class="line">    return futures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下BackgroundCompactionTask的Run()方法，该方法中主要根据合并策略（AbstractCompactionStrategy的实现类）获取一个CompactionTask，如何该task不为空就执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        logger.debug(&quot;Checking &#123;&#125;.&#123;&#125;&quot;, cfs.keyspace.getName(), cfs.name);</span><br><span class="line">        if (!cfs.isValid()) &#123;</span><br><span class="line">            logger.debug(&quot;Aborting compaction for dropped CF&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();</span><br><span class="line">        AbstractCompactionTask task = strategy.getNextBackgroundTask(getDefaultGcBefore(cfs));</span><br><span class="line">        if (task == null) &#123;</span><br><span class="line">            logger.debug(&quot;No tasks available&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        task.execute(metrics);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        compactingCF.remove(cfs);</span><br><span class="line">    &#125;</span><br><span class="line">    submitBackground(cfs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getNextBackgroundTask()方法中最主要的是找出需要执行合并的sstable。以SizeTieredCompactionStrategy为例，其实现流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SSTableReader&gt; getNextBackgroundSSTables(final int gcBefore) &#123;</span><br><span class="line">    if (!isEnabled())</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    // make local copies so they can&#x27;t be changed out from under us mid-method</span><br><span class="line">    int minThreshold = cfs.getMinimumCompactionThreshold();</span><br><span class="line">    int maxThreshold = cfs.getMaximumCompactionThreshold();</span><br><span class="line"></span><br><span class="line">    // 1.忽略isSuspect属性为trued的sstable</span><br><span class="line">    Iterable&lt;SSTableReader&gt; candidates = filterSuspectSSTables(cfs.getUncompactingSSTables());</span><br><span class="line">    // 2.过滤冷数据块</span><br><span class="line">    candidates = filterColdSSTables(Lists.newArrayList(candidates), options.coldReadsToOmit);</span><br><span class="line"></span><br><span class="line">    // 3.根据相似尺寸来分桶，小于minSSTableSize的所有sstable会分到同一个桶</span><br><span class="line">    List&lt;List&lt;SSTableReader&gt;&gt; buckets = getBuckets(createSSTableAndLengthPairs(candidates), options.bucketHigh,</span><br><span class="line">            options.bucketLow, options.minSSTableSize);</span><br><span class="line">    logger.debug(&quot;Compaction buckets are &#123;&#125;&quot;, buckets);</span><br><span class="line">    updateEstimatedCompactionsByTasks(buckets);</span><br><span class="line">    // 4.在分组里面取出“最感兴趣”的</span><br><span class="line">    List&lt;SSTableReader&gt; mostInteresting = mostInterestingBucket(buckets, minThreshold, maxThreshold);</span><br><span class="line">    if (!mostInteresting.isEmpty())</span><br><span class="line">        return mostInteresting;</span><br><span class="line"></span><br><span class="line">    // if there is no sstable to compact in standard way, try compacting single sstable whose droppable tombstone</span><br><span class="line">    // ratio is greater than threshold.</span><br><span class="line">    List&lt;SSTableReader&gt; sstablesWithTombstones = new ArrayList&lt;&gt;();</span><br><span class="line">    for (SSTableReader sstable : candidates) &#123;</span><br><span class="line">        // 5.查找需要清理tombstone的sstable</span><br><span class="line">        if (worthDroppingTombstones(sstable, gcBefore))</span><br><span class="line">            sstablesWithTombstones.add(sstable);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sstablesWithTombstones.isEmpty())</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    Collections.sort(sstablesWithTombstones, new SSTableReader.SizeComparator());</span><br><span class="line">    return Collections.singletonList(sstablesWithTombstones.get(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>第2步过滤冷数据块中，数据的“热度（hotness）”定义为2小时内的访问次数除以块中的估计的key的数量，把sstable根据hotness排序后，过滤掉hotness最小且访问次数和小于(coldReadsToOmit * 所有块的读取总数)的若干个数据块。</li>
<li>第4步中，首先在各个分组中找出hotness最大的若干个（不超过maxThreshold，如果小于minThreshold，则忽略）sstable，然后把各个组的这些sstable的hotness计算总和，找出hotness和最大的那个分组的若干个sstable返回。</li>
<li>第5步中，查找需要清理tombstone的sstable。对于某个sstable，判断是否需要清理的判断过程如下：<ol>
<li>如果自创建sstable的时间起到当前时间小于合并的时间间隔tombstoneCompactionInterval（默认为1天），则直接返回false。</li>
<li>如果估算的tombstone所占的比例小于tombstoneThreshold（默认为0.2f），则直接返回false。</li>
<li>查找是否存在和此sstable的key范围有重叠的其他sstable，如果不存在，返回true（因为这样可以安全地清除tombstone，否则的话可能会使得删除的记录“复活”）；否则进入下一步。</li>
<li>有key重合，但是此sstable已经过期，也返回true。过期是指此sstable的最大修改时间也小于其他sstable的最小修改时间，也可以清除tombstone，因为即使某个tombstone对应的key在其他sstable中存在记录，但是由于时间更新，也会覆盖tombstone，所以tombstone可以安全清除；否则进入下一步。</li>
<li>估算此sstable和其他sstable不重合的key范围的column数量所占比例，如果超过一定大小返回true，否则返回false。</li>
</ol>
</li>
</ul>
<p>下面来看合并的执行过程，主要逻辑在CompactionTask的runMayThrow()方法中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">protected void runMayThrow() throws Exception &#123;</span><br><span class="line">        // The collection of sstables passed may be empty (but not null); even if</span><br><span class="line">        // it is not empty, it may compact down to nothing if all rows are deleted.</span><br><span class="line">        assert sstables != null;</span><br><span class="line"></span><br><span class="line">        AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();</span><br><span class="line"></span><br><span class="line">        if (DatabaseDescriptor.isSnapshotBeforeCompaction()) // 合并前之前快照</span><br><span class="line">            cfs.snapshotWithoutFlush(System.currentTimeMillis() + &quot;-compact-&quot; + cfs.name);</span><br><span class="line"></span><br><span class="line">        // 在合并前需要估算下磁盘空间是否足够</span><br><span class="line">        long earlySSTableEstimate = Math.max(1,</span><br><span class="line">                cfs.getExpectedCompactedFileSize(toCompact, compactionType) / strategy.getMaxSSTableBytes());</span><br><span class="line">        checkAvailableDiskSpace(earlySSTableEstimate);</span><br><span class="line"></span><br><span class="line">        // sanity check: all sstables must belong to the same cfs</span><br><span class="line">        for (SSTableReader sstable : toCompact)</span><br><span class="line">            assert sstable.descriptor.cfname.equals(cfs.name);</span><br><span class="line">        </span><br><span class="line">        // 写入compact log</span><br><span class="line">        UUID taskId = SystemKeyspace.startCompaction(cfs, toCompact);</span><br><span class="line"></span><br><span class="line">        CompactionController controller = getCompactionController(toCompact);</span><br><span class="line">        // TODO 为什么排除expired sstable</span><br><span class="line">        Set&lt;SSTableReader&gt; actuallyCompact = Sets.difference(toCompact, controller.getFullyExpiredSSTables());</span><br><span class="line"></span><br><span class="line">        // new sstables from flush can be added during a compaction, but only the compaction can remove them,</span><br><span class="line">        // so in our single-threaded compaction world this is a valid way of determining if we&#x27;re compacting</span><br><span class="line">        // all the sstables (that existed when we started)</span><br><span class="line">        logger.info(&quot;Compacting &#123;&#125;&quot;, toCompact);</span><br><span class="line"></span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        long totalKeysWritten = 0;</span><br><span class="line"></span><br><span class="line">        long estimatedTotalKeys = Math.max(cfs.metadata.getIndexInterval(),</span><br><span class="line">                SSTableReader.getApproximateKeyCount(actuallyCompact, cfs.metadata)); // 估算需要合并的sstable中key的总数</span><br><span class="line">        long estimatedSSTables = Math.max(1, getExpectedWriteSize() / strategy.getMaxSSTableBytes());</span><br><span class="line">        long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);</span><br><span class="line">       </span><br><span class="line">        // AbstractCompactionIterable 也是一个多路合并的迭代器，和读取过程是类似的</span><br><span class="line">        AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction()</span><br><span class="line">                ? new ParallelCompactionIterable(compactionType, strategy.getScanners(actuallyCompact), controller)</span><br><span class="line">                : new CompactionIterable(compactionType, strategy.getScanners(actuallyCompact), controller);</span><br><span class="line">        CloseableIterator&lt;AbstractCompactedRow&gt; iter = ci.iterator();</span><br><span class="line">        Map&lt;DecoratedKey, RowIndexEntry&gt; cachedKeys = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // we can&#x27;t preheat until the tracker has been set. This doesn&#x27;t happen until we tell the cfs to</span><br><span class="line">        // replace the old entries.  Track entries to preheat here until then.</span><br><span class="line">        // 缓存需要预热的索引项</span><br><span class="line">        Map&lt;Descriptor, Map&lt;DecoratedKey, RowIndexEntry&gt;&gt; cachedKeyMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Collection&lt;SSTableReader&gt; sstables = new ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;SSTableWriter&gt; writers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        if (collector != null)</span><br><span class="line">            collector.beginCompaction(ci);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!iter.hasNext()) &#123;</span><br><span class="line">                // don&#x27;t mark compacted in the finally block, since if there _is_ nondeleted data,</span><br><span class="line">                // we need to sync it (via closeAndOpen) first, so there is no period during which</span><br><span class="line">                // a crash could cause data loss. TODO ???</span><br><span class="line">                cfs.markObsolete(toCompact, compactionType);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long writeSize = getExpectedWriteSize() / estimatedSSTables; // 预估要写入的数据大小</span><br><span class="line">            Directories.DataDirectory dataDirectory = getWriteDirectory(writeSize); // 获取写入目录</span><br><span class="line">            SSTableWriter writer = createCompactionWriter(cfs.directories.getLocationForDisk(dataDirectory), keysPerSSTable);</span><br><span class="line">            writers.add(writer);</span><br><span class="line">            while (iter.hasNext()) &#123;</span><br><span class="line">                if (ci.isStopRequested())</span><br><span class="line">                    throw new CompactionInterruptedException(ci.getCompactionInfo());</span><br><span class="line"></span><br><span class="line">                AbstractCompactedRow row = iter.next();</span><br><span class="line">                RowIndexEntry indexEntry = writer.append(row);</span><br><span class="line">                if (indexEntry == null) &#123;</span><br><span class="line">                    // 只有合并之后所有column全为tombstone才返回null，也就是该key其实没数据了</span><br><span class="line">                    controller.invalidateCachedRow(row.key);</span><br><span class="line">                    row.close();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                totalKeysWritten++;</span><br><span class="line"></span><br><span class="line">                if (DatabaseDescriptor.getPreheatKeyCache()) &#123; // 需要预热key cache</span><br><span class="line">                    for (SSTableReader sstable : actuallyCompact) &#123;</span><br><span class="line">                        if (sstable.getCachedPosition(row.key, false) != null) &#123;</span><br><span class="line">                            cachedKeys.put(row.key, indexEntry);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (newSSTableSegmentThresholdReached(writer)) &#123;</span><br><span class="line">                    // tmp = false because later we want to query it with descriptor from SSTableReader</span><br><span class="line">                    cachedKeyMap.put(writer.descriptor.asTemporary(false), cachedKeys);</span><br><span class="line">                    writeSize = getExpectedWriteSize() / estimatedSSTables;</span><br><span class="line">                    dataDirectory = getWriteDirectory(writeSize);</span><br><span class="line">                    writer = createCompactionWriter(cfs.directories.getLocationForDisk(dataDirectory), keysPerSSTable);</span><br><span class="line">                    writers.add(writer);</span><br><span class="line">                    cachedKeys = new HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (writer.getFilePointer() &gt; 0) &#123;</span><br><span class="line">                cachedKeyMap.put(writer.descriptor.asTemporary(false), cachedKeys);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                writer.abort();</span><br><span class="line">                writers.remove(writer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long maxAge = getMaxDataAge(toCompact);</span><br><span class="line">            for (SSTableWriter completedWriter : writers) // 关闭writer同时打开reader</span><br><span class="line">                sstables.add(completedWriter.closeAndOpenReader(maxAge));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            for (SSTableWriter writer : writers)</span><br><span class="line">                writer.abort();</span><br><span class="line">            // also remove already completed SSTables</span><br><span class="line">            for (SSTableReader sstable : sstables) &#123;</span><br><span class="line">                sstable.markObsolete();</span><br><span class="line">                sstable.releaseReference();</span><br><span class="line">            &#125;</span><br><span class="line">            throw Throwables.propagate(t);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            controller.close();</span><br><span class="line"></span><br><span class="line">            // point of no return -- the new sstables are live on disk; next we&#x27;ll start deleting the old ones</span><br><span class="line">            // (in replaceCompactedSSTables)</span><br><span class="line">            if (taskId != null)</span><br><span class="line">                SystemKeyspace.finishCompaction(taskId);</span><br><span class="line"></span><br><span class="line">            if (collector != null)</span><br><span class="line">                collector.finishCompaction(ci);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // We don&#x27;t expect this to throw, but just in case, we do it after the cleanup above, to make sure</span><br><span class="line">                // we don&#x27;t end up with compaction information hanging around indefinitely in limbo.</span><br><span class="line">                iter.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 用新生的sstable替换被合并的sstable</span><br><span class="line">        replaceCompactedSSTables(toCompact, sstables);</span><br><span class="line">        // TODO: this doesn&#x27;t belong here, it should be part of the reader to load when the tracker is wired up</span><br><span class="line">        for (SSTableReader sstable : sstables) &#123;</span><br><span class="line">            if (sstable.acquireReference()) &#123; /</span><br><span class="line">                try &#123;</span><br><span class="line">                    sstable.preheat(cachedKeyMap.get(sstable.descriptor)); // 预热索引项</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sstable.releaseReference();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // log a bunch of statistics about the result and save to system table compaction_history</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在合并的过程中，同一个key对应的多个row的合并由getCompactedRow()方法处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public AbstractCompactedRow getCompactedRow(List&lt;SSTableIdentityIterator&gt; rows) &#123;</span><br><span class="line">    long rowSize = 0;</span><br><span class="line">    for (SSTableIdentityIterator row : rows)</span><br><span class="line">        rowSize += row.dataSize;</span><br><span class="line"></span><br><span class="line">    if (rowSize &gt; DatabaseDescriptor.getInMemoryCompactionLimit()) &#123;</span><br><span class="line">        String keyString = cfs.metadata.getKeyValidator().getString(rows.get(0).getKey().key);</span><br><span class="line">        logger.info(String.format(&quot;Compacting large row %s/%s:%s (%d bytes) incrementally&quot;,</span><br><span class="line">                cfs.keyspace.getName(), cfs.name, keyString, rowSize));</span><br><span class="line">        return new LazilyCompactedRow(this, rows);</span><br><span class="line">    &#125;</span><br><span class="line">    return new PrecompactedRow(this, rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当要合并的数据小于in_memory_compaction_limit_in_mb(64)MB时，会创建PrecompactedRow对象，调用的构造方法如下，可以发现在构造方法中就进行了数据的读取和合并，之后还会清除被删除的列，需要注意的是removeDeleted方法中仍然需要判断tombstone标记的列是否应该删除，判断的方法和之前的类似，从intervalTree中查找包含该key的sstable，如果这些sstable的minTimestamp大于合并后的maxTimestamp则可以清除tombstone。否则，如果这些sstable中不包含该key，那么也是可以清除的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public PrecompactedRow(CompactionController controller, List&lt;SSTableIdentityIterator&gt; rows) &#123;</span><br><span class="line">    this(rows.get(0).getKey(), removeDeleted(rows.get(0).getKey(), controller, merge(rows, controller)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要合并的数据太多则会使用LazilyCompactedRow，在迭代的时候才会进行合并。</p>
<hr>
<p><strong>IntervalTree</strong></p>
<p>在查找key范围有重叠的sstable时，cassandra中使用了一个称为IntervalTree的数据结构。IntervalTree的节点用IntervalNode表示，主要属性如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private class IntervalNode &#123;</span><br><span class="line">    final C center; // 所有区间的中点</span><br><span class="line">    final C low;    // 所有区间的最小值</span><br><span class="line">    final C high;   // 所有区间的最大值</span><br><span class="line"></span><br><span class="line">    final List&lt;I&gt; intersectsLeft;  // 包含center的区间，按照区间的左值升序</span><br><span class="line">    final List&lt;I&gt; intersectsRight; // 包含center的区间，按照区间的右值降序</span><br><span class="line"></span><br><span class="line">    final IntervalNode left;  // 左子树</span><br><span class="line">    final IntervalNode right; // 右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建构IntervalTree的方法，参数是所有的区间，返回根节点，根节点涵盖了所有的区间范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public IntervalNode(Collection&lt;I&gt; toBisect) &#123;</span><br><span class="line">    assert !toBisect.isEmpty();</span><br><span class="line">    logger.trace(&quot;Creating IntervalNode from &#123;&#125;&quot;, toBisect);</span><br><span class="line"></span><br><span class="line">    // Building IntervalTree with one interval will be a reasonably</span><br><span class="line">    // common case for range tombstones, so it&#x27;s worth optimizing</span><br><span class="line">    if (toBisect.size() == 1) &#123;</span><br><span class="line">        I interval = toBisect.iterator().next();</span><br><span class="line">        low = interval.min;</span><br><span class="line">        center = interval.max;</span><br><span class="line">        high = interval.max;</span><br><span class="line">        List&lt;I&gt; l = Collections.singletonList(interval);</span><br><span class="line">        intersectsLeft = l;</span><br><span class="line">        intersectsRight = l;</span><br><span class="line">        left = null;</span><br><span class="line">        right = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 找出最大，最小和中间值</span><br><span class="line">        List&lt;C&gt; allEndpoints = new ArrayList&lt;&gt;(toBisect.size() * 2);</span><br><span class="line">        for (I interval : toBisect) &#123;</span><br><span class="line">            assert (comparator == null ? ((Comparable) interval.min).compareTo(interval.max)</span><br><span class="line">                    : comparator.compare(interval.min, interval.max)) &lt;= 0 : &quot;Interval min &gt; max&quot;;</span><br><span class="line">            allEndpoints.add(interval.min);</span><br><span class="line">            allEndpoints.add(interval.max);</span><br><span class="line">        &#125;</span><br><span class="line">        // 排序</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            Collections.sort(allEndpoints, comparator);</span><br><span class="line">        else</span><br><span class="line">            Collections.sort((List&lt;Comparable&gt;) allEndpoints);</span><br><span class="line"></span><br><span class="line">        low = allEndpoints.get(0); //最小值</span><br><span class="line">        center = allEndpoints.get(toBisect.size()); // 中点</span><br><span class="line">        high = allEndpoints.get(allEndpoints.size() - 1); // 最大值</span><br><span class="line"></span><br><span class="line">        // 根据是否包含center，分隔成区间不相交的三部分</span><br><span class="line">        List&lt;I&gt; intersects = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;I&gt; leftSegment = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;I&gt; rightSegment = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for (I candidate : toBisect) &#123;</span><br><span class="line">            if (comparePoints(candidate.max, center) &lt; 0) // 不包含center，且最大值小于center，归属于左子树</span><br><span class="line">                leftSegment.add(candidate);</span><br><span class="line">            else if (comparePoints(candidate.min, center) &gt; 0) // 不包含center，且最小值大于center，归属于右子树</span><br><span class="line">                rightSegment.add(candidate);</span><br><span class="line">            else</span><br><span class="line">                intersects.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        intersectsLeft = minOrdering.sortedCopy(intersects);</span><br><span class="line">        intersectsRight = maxOrdering.reverse().sortedCopy(intersects);</span><br><span class="line">        left = leftSegment.isEmpty() ? null : new IntervalNode(leftSegment); // 构建左子树</span><br><span class="line">        right = rightSegment.isEmpty() ? null : new IntervalNode(rightSegment); // 构建右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从IntervalTree中查找和指定区间相交的所有区间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void searchInternal(Interval&lt;C, D&gt; searchInterval, List&lt;D&gt; results) &#123;</span><br><span class="line">    // 区间外</span><br><span class="line">    if (comparePoints(searchInterval.max, low) &lt; 0 || comparePoints(searchInterval.min, high) &gt; 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (contains(searchInterval, center)) &#123; // 包含center节点</span><br><span class="line">        // Adds every interval contained in this node to the result set then search left and right for further</span><br><span class="line">        // overlapping intervals</span><br><span class="line">        for (Interval&lt;C, D&gt; interval : intersectsLeft)</span><br><span class="line">            results.add(interval.data);</span><br><span class="line"></span><br><span class="line">        if (left != null)</span><br><span class="line">            left.searchInternal(searchInterval, results);</span><br><span class="line">        if (right != null)</span><br><span class="line">            right.searchInternal(searchInterval, results);</span><br><span class="line">    &#125; else if (comparePoints(center, searchInterval.min) &lt; 0) &#123; // 可能和右子树或intersectsRight的元素相交</span><br><span class="line">        // Adds intervals i in intersects right as long as i.max &gt;= searchInterval.min</span><br><span class="line">        // then search right</span><br><span class="line">        for (Interval&lt;C, D&gt; interval : intersectsRight) &#123;</span><br><span class="line">            if (comparePoints(interval.max, searchInterval.min) &gt;= 0)</span><br><span class="line">                results.add(interval.data);</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right != null)</span><br><span class="line">            right.searchInternal(searchInterval, results);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assert comparePoints(center, searchInterval.max) &gt; 0; // 可能和左子树或intersectsLeft的元素相交</span><br><span class="line">        // Adds intervals i in intersects left as long as i.min &gt;= searchInterval.max</span><br><span class="line">        // then search left</span><br><span class="line">        for (Interval&lt;C, D&gt; interval : intersectsLeft) &#123;</span><br><span class="line">            if (comparePoints(interval.min, searchInterval.max) &lt;= 0)</span><br><span class="line">                results.add(interval.data);</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left != null)</span><br><span class="line">            left.searchInternal(searchInterval, results);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实现上看，该IntervalTree不支持增删节点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/10/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%947-COMPACTION/" data-id="ckzldzrav000ztofw99ihednd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cassandra/" rel="tag">Cassandra</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/16/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%948-Gossip%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Cassandra源码阅读随笔8. Gossip协议和故障检测
        
      </div>
    </a>
  
  
    <a href="/2019/09/28/Cassandra%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%946-UPDATE%E5%92%8CDELETE%E6%93%8D%E4%BD%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Cassandra源码阅读随笔6. UPDATE和DELETE操作</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BookKeeper/" rel="tag">BookKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cassandra/" rel="tag">Cassandra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HBase/" rel="tag">HBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Parser-combinator/" rel="tag">Parser combinator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pulasr/" rel="tag">Pulasr</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BookKeeper/" style="font-size: 10px;">BookKeeper</a> <a href="/tags/Cassandra/" style="font-size: 20px;">Cassandra</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/Parser-combinator/" style="font-size: 10px;">Parser combinator</a> <a href="/tags/Pulasr/" style="font-size: 10px;">Pulasr</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/07/Parser-combinator%E5%88%9D%E6%8E%A21-%E7%AE%80%E6%98%93JSON%E8%A7%A3%E6%9E%90%E5%99%A8/">Parser combinator初探1-简易JSON解析器</a>
          </li>
        
          <li>
            <a href="/2019/12/28/Cassandra%E7%AC%94%E8%AE%B01-Compaction%E7%AD%96%E7%95%A5/">Cassandra笔记1-Compaction策略</a>
          </li>
        
          <li>
            <a href="/2019/11/27/HBase%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942-MemStore/">HBase源码阅读随笔2-MemStore</a>
          </li>
        
          <li>
            <a href="/2019/11/17/%E8%AF%91-Pulsar%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/">[译]-Pulsar简要介绍</a>
          </li>
        
          <li>
            <a href="/2019/11/10/%E8%AF%91-BookKeeper%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/">[译]BookKeeper简要介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Bao Qingping<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>